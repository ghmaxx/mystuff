local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Players = game.Players
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TextChatService = game:GetService("TextChatService")

local player = Players.LocalPlayer
local MapFolder = workspace:WaitForChild("map")

-- Goal references
local GkBarrier = MapFolder:FindFirstChild("gkbarriar")
local AGoal = MapFolder:FindFirstChild("Agoal")
local BGoal = MapFolder:FindFirstChild("Bgoal")
local AGk = workspace:FindFirstChild("A")
local BGk = workspace:FindFirstChild("B")

local trapDelay = 0.08
local scriptActive = true
local aimbotDistance = 200
local aimbotShootTime = 0.265
local stealLoop = 1

local function isInGame()
	if not scriptActive then return false end
	local LocalCharacter = player.Character
	if not LocalCharacter then return false end

	local StateFolder = LocalCharacter:FindFirstChild("state")
	if not StateFolder then return false end

	local InGameValue = StateFolder:FindFirstChild("ingame")
	if not InGameValue then return false end

	return InGameValue.Value
end

local function DisableCollisionBoxes()
	if not scriptActive then return end
	if GkBarrier then
		local ABarrier = GkBarrier:FindFirstChild("Abarriar")
		local BBarrier = GkBarrier:FindFirstChild("Bbarriar")

		if ABarrier then ABarrier.CanCollide = false end
		if BBarrier then BBarrier.CanCollide = false end
	end

	if AGoal then AGoal.CanCollide = false end
	if BGoal then BGoal.CanCollide = false end
end

local function DisableCollisionBoxesC(cmd)
	if not scriptActive then return end
	if GkBarrier then
		local ABarrier = GkBarrier:FindFirstChild("Abarriar")
		local BBarrier = GkBarrier:FindFirstChild("Bbarriar")

		if ABarrier then ABarrier.CanCollide = cmd end
		if BBarrier then BBarrier.CanCollide = cmd end
	end

	if AGoal then AGoal.CanCollide = cmd end
	if BGoal then BGoal.CanCollide = cmd end
end

local function StealBall()
	if not scriptActive then return end
	local LocalCharacter = player.Character
	local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
	local Football = workspace.Terrain:FindFirstChild("Ball")

	if LocalHumanoidRootPart and Football then
		LocalHumanoidRootPart.CFrame = CFrame.new(Football.Position + Vector3.new(0, 2, 0))
		task.wait(0.1)
	end

	for _, OtherPlayer in pairs(Players:GetPlayers()) do
		if OtherPlayer ~= player then
			local OtherCharacter = OtherPlayer.Character
			local OtherFootball = OtherCharacter and OtherCharacter:FindFirstChild("Ball")
			local OtherRoot = OtherCharacter and OtherCharacter:FindFirstChild("HumanoidRootPart")

			if OtherFootball and OtherRoot and LocalHumanoidRootPart then
				LocalHumanoidRootPart.CFrame = OtherRoot.CFrame + Vector3.new(0, 2, 0)
				task.wait(0.1)
				VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
				VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
				break
			end
		end
	end
end

local function HasBall()
	if not scriptActive then return false end
	local LocalCharacter = player.Character
	if not LocalCharacter then return false end

	local BallInCharacter = LocalCharacter:FindFirstChild("Ball")
	if BallInCharacter then return true end

	local Football = workspace.Terrain:FindFirstChild("Ball")
	if Football and Football:FindFirstChild("owner") then
		return Football.owner.Value == player
	end

	return false
end

local function DoGoal()
	if not scriptActive then return end
	if not isInGame() then return end

	DisableCollisionBoxes()

	if not HasBall() then
		StealBall()
	end

	local startTime = tick()
	while not HasBall() and tick() - startTime < 2 do
		StealBall()
		task.wait(0.05)
	end

	if HasBall() then
		local LocalCharacter = player.Character
		local LocalRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
		local Goal = player.Team and player.Team.Name == "A" and BGoal or AGoal

		if not LocalRootPart or not Goal then return end

		LocalRootPart.CFrame = Goal.CFrame
		task.wait(0.1)
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
		VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
	end
end

DisableCollisionBoxes()

local function DoStealLoop()
	if not scriptActive then return end
	local active = true

	local conn
	conn = RunService.RenderStepped:Connect(function()
		if not active or not scriptActive then
			conn:Disconnect()
			return
		end

		local LocalCharacter = player.Character
		local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")

		for _, OtherPlayer in pairs(Players:GetPlayers()) do
			if OtherPlayer ~= player then
				local OtherCharacter = OtherPlayer.Character
				local OtherFootball = OtherCharacter and OtherCharacter:FindFirstChild("Ball")
				local OtherRoot = OtherCharacter and OtherCharacter:FindFirstChild("HumanoidRootPart")

				if OtherFootball and OtherRoot and LocalHumanoidRootPart then
					LocalHumanoidRootPart.CFrame = OtherRoot.CFrame + Vector3.new(0, 2, 0)
					break
				end
			end
		end
	end)

	task.delay(stealLoop, function()
		active = false
	end)
end

local function findStyle(style)
    local playerStyle = player:GetAttribute("style")
    print(playerStyle)
    if playerstyle ~= style then print("not using:", style) return false else print("using:", style) return true end
end

local function isCooldown(num)
    local playerGui = player.PlayerGui
    local Hotbar = playerGui.Hotbar.Backpack.Hotbar
    local skill = Hotbar:FindFirstChild("skill"..num)
    local onCooldown
    if skill then
        local scooldown = skill.Cooldown
        if scooldown.Size ~= UDim2.new(1,0,0,0) then onCooldown = true else onCooldown = false end
    end
    print(onCooldown and "skill"..num.." is on cooldown" or "skill"..num.." is not on cooldown")
    return onCooldown
end

local function DoTrap()
	if not scriptActive then return end
	if not isInGame() then return end
    --if not findStyle("nagi") then return end
    if isCooldown(2) then return end

	VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
	VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)

	task.wait(trapDelay)

	local LocalCharacter = player.Character
	local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")

	if not LocalHumanoidRootPart then return end

	local startTime = tick()
	local glideDuration = 1.5

	local conn
	conn = RunService.RenderStepped:Connect(function()
		local now = tick()
		if now - startTime > glideDuration then
			conn:Disconnect()
			return
		end

		local Football = workspace.Terrain:FindFirstChild("Ball")
		if not Football then return end

		local velocity = Football.AssemblyLinearVelocity
		local speed = velocity.Magnitude

		local followOffset
		if speed > 1 then
			local direction = velocity.Unit
			followOffset = direction * 2 + Vector3.new(0, 0.5, 0)
		else
			followOffset = Vector3.new(0, 1.5, 0)
		end

		local targetPos = Football.Position + followOffset
		local currentPos = LocalHumanoidRootPart.Position
		local lerpedPos = currentPos:Lerp(targetPos, 0.2)
		LocalHumanoidRootPart.CFrame = CFrame.new(lerpedPos)
	end)
end

local function Shoot()
	if not scriptActive then return end
	if not isInGame() then return end

	print('req shoot')

	local LocalCharacter = player.Character
	local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
	local Humanoid = LocalCharacter and LocalCharacter:FindFirstChildOfClass("Humanoid")

	if not LocalHumanoidRootPart then return end

	local targetGoal = nil
	local distanceToAGoal = (LocalHumanoidRootPart.Position - AGoal.Position).Magnitude
	local distanceToBGoal = (LocalHumanoidRootPart.Position - BGoal.Position).Magnitude

	if distanceToAGoal <= aimbotDistance then
		targetGoal = AGoal
	elseif distanceToBGoal <= aimbotDistance then
		targetGoal = BGoal
	end

	if not targetGoal then return end

	if Humanoid then
		Humanoid.AutoRotate = false
	end

	local shootTarget
	local gk = player.Team and player.Team.Name == "A" and BGk or AGk
	if gk and gk:FindFirstChild("HumanoidRootPart") then
		local gkPos = gk.HumanoidRootPart.Position
		local goalSize = targetGoal.Size.X
		local leftSide = targetGoal.Position - targetGoal.CFrame.RightVector * (goalSize / 2)
		local rightSide = targetGoal.Position + targetGoal.CFrame.RightVector * (goalSize / 2)

		if (gkPos - leftSide).Magnitude < (gkPos - rightSide).Magnitude then
			shootTarget = rightSide
		else
			shootTarget = leftSide
		end
	else
		shootTarget = targetGoal.Position
	end

	local rotating = true
	local conn
	conn = RunService.RenderStepped:Connect(function()
		if not rotating or not LocalHumanoidRootPart then
			conn:Disconnect()
			return
		end
		LocalHumanoidRootPart.CFrame = CFrame.new(LocalHumanoidRootPart.Position, shootTarget)
	end)

	VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
	task.wait(aimbotShootTime)
	VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)

	rotating = false
	if Humanoid then
		Humanoid.AutoRotate = true
	end
end

local Window = Fluent:CreateWindow({
    Title = "Azure Latch " .. Fluent.Version,
    SubTitle = "by ghmaxx",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    Keybinds = Window:AddTab({ Title = "Keybinds", Icon = "keyboard" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

do
    Fluent:Notify({
        Title = "Warning",
        Content = "Do not use this script on a main account, as if you are caught exploiting it will lead to an unappealable permanent ban.",
        SubContent = "This will disappear in 10 seconds.", -- Optional
        Duration = 10 -- Set to nil to make the notification not disappear
    })



    Tabs.Main:AddParagraph({
        Title = "Information",
        Content = "This section contains the main exploits.\nExpect improvements!"
    })

    Tabs.Main:AddButton({
        Title = "Goal",
        Description = "Make a goal.",
        Callback = function()
            DoGoal()
        end
    })

    Tabs.Main:AddButton({
        Title = "Trap ball",
        Description = "Control the ball.",
        Callback = function()
            DoTrap()
        end
    })

    Tabs.Main:AddButton({
        Title = "Steal ball",
        Description = "Steal the ball.",
        Callback = function()
            StealBall()
        end
    })

    Tabs.Main:AddButton({
        Title = "Shoot ball",
        Description = "Shoot the ball (aim at goal).",
        Callback = function()
            Shoot()
        end
    })

    local Toggle = Tabs.Main:AddToggle("CrowdToggle", {Title = "Crowd", Default = true })
    local CollisionToggle = Tabs.Main:AddToggle("CollisionToggle", {Title = "Collision Boxes", Default = false })

    CollisionToggle:OnChanged(function()
        DisableCollisionBoxesC(Options.CollisionToggle.Value)
    end)

    Toggle:OnChanged(function()
        print("Toggle changed:", Options.CrowdToggle.Value)
        game.SoundService:FindFirstChild("football-crowd-3-69245").Playing = Options.CrowdToggle.Value
    end)
    
    local CFWS = Tabs.Main:AddToggle("CFrameWS", {Title = "Enable CFrame Walkspeed", Default = false })

    local CFWSS = Tabs.Main:AddSlider("Slider", {
        Title = "CFrame Walkspeed",
        Description = "Adjust the walkspeed",
        Default = 1,
        Min = 0,
        Max = 5,
        Rounding = 1,
        Callback = function(Value)
            print("Slider was changed:", Value)
        end
    })

    local CFsliderv = 1

    CFWSS:OnChanged(function(Value)
        print("Slider changed:", Value)
        CFsliderv = Value  
    end)

    CFWSS:SetValue(1)

    CFWS:OnChanged(function()
        print("Toggle changed:", Options.CFrameWS.Value)
        task.spawn(function()
            while Options.CFrameWS.Value == true do
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame + game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.lookVector * CFsliderv
                wait()  
            end
        end)
    end)

    local GoalK = Tabs.Keybinds:AddKeybind("Keybind", {
        Title = "Goal",
        Mode = "Toggle", -- Always, Toggle, Hold
        Default = "none", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

        -- Occurs when the keybind is clicked, Value is `true`/`false`
        Callback = function(Value)

        end,
    })

    -- OnClick is only fired when you press the keybind and the mode is Toggle
    -- Otherwise, you will have to use Keybind:GetState()
    GoalK:OnClick(function()
         DoGoal()
    end)
    GoalK:SetValue("none", "Toggle")

    local TrapK = Tabs.Keybinds:AddKeybind("Keybind", {
        Title = "Trap",
        Mode = "Toggle", -- Always, Toggle, Hold
        Default = "none", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

        -- Occurs when the keybind is clicked, Value is `true`/`false`
        Callback = function(Value)
        end,
    })

    -- OnClick is only fired when you press the keybind and the mode is Toggle
    -- Otherwise, you will have to use Keybind:GetState()
    TrapK:OnClick(function()
         DoTrap()
    end)
    TrapK:SetValue("none", "Toggle")

    local StealK = Tabs.Keybinds:AddKeybind("Keybind", {
        Title = "Steal",
        Mode = "Toggle", -- Always, Toggle, Hold
        Default = "none", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

        -- Occurs when the keybind is clicked, Value is `true`/`false`
        Callback = function(Value)

        end,
    })

    -- OnClick is only fired when you press the keybind and the mode is Toggle
    -- Otherwise, you will have to use Keybind:GetState()
    StealK:OnClick(function()
         StealBall()
    end)
    StealK:SetValue("none", "Toggle")
    
    local ShootK = Tabs.Keybinds:AddKeybind("Keybind", {
        Title = "Aimbot Shot",
        Mode = "Toggle", -- Always, Toggle, Hold
        Default = "none", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

        -- Occurs when the keybind is clicked, Value is `true`/`false`
        Callback = function(Value)

        end,
    })

    -- OnClick is only fired when you press the keybind and the mode is Toggle
    -- Otherwise, you will have to use Keybind:GetState()
    ShootK:OnClick(function()
         Shoot()
    end)
    ShootK:SetValue("none", "Toggle")

    local Input = Tabs.Main:AddInput("Input", {
        Title = "Input",
        Default = "Default",
        Placeholder = "Placeholder",
        Numeric = false, -- Only allows numbers
        Finished = false, -- Only calls callback when you press enter
        Callback = function(Value)
            print("Input changed:", Value)
        end
    })

    Input:OnChanged(function()
        print("Input updated:", Input.Value)
    end)
end


-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)


Window:SelectTab(1)

Fluent:Notify({
    Title = "Fluent",
    Content = "The script has been loaded.",
    Duration = 8
})

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
